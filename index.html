<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Transcription + Translation</title>
  <style>
    :root {
      --bg: #f3f7fb;
      --surface: #ffffff;
      --text: #12263a;
      --muted: #4f6476;
      --border: #d6e2ee;
      --brand: #0d6efd;
      --brand-dark: #0b5ed7;
      --ok: #198754;
      --error: #dc3545;
      --shadow: 0 10px 30px rgba(17, 36, 58, 0.08);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Segoe UI", "Avenir Next", "Helvetica Neue", sans-serif;
      background:
        radial-gradient(circle at top right, #dbeafe 0%, transparent 45%),
        radial-gradient(circle at top left, #e0f2fe 0%, transparent 40%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 28px 14px;
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      display: grid;
      gap: 16px;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 18px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.3rem, 2.3vw, 1.9rem);
      line-height: 1.25;
      letter-spacing: 0.01em;
    }

    .subtitle {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.98rem;
    }

    .controls {
      display: grid;
      gap: 12px;
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    input[type="file"] {
      width: 100%;
      border: 1px dashed #95b8d6;
      border-radius: 12px;
      padding: 10px;
      background: #f8fbff;
      color: var(--muted);
    }

    button {
      border: 0;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--brand), #2f80ed);
      color: white;
      font-weight: 600;
      padding: 10px 16px;
      cursor: pointer;
      transition: transform 0.12s ease, filter 0.12s ease;
    }

    button:hover {
      filter: brightness(1.03);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    #s {
      margin: 0;
      font-size: 0.94rem;
      color: var(--muted);
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      padding: 6px 10px;
      background: #e7f1ff;
      color: #0b4ea2;
      border: 1px solid #cfe2ff;
    }

    .status[data-state="done"] {
      background: #eaf9f0;
      color: #146c43;
      border-color: #c3e6d2;
    }

    .status[data-state="error"] {
      background: #fdecef;
      color: #b02a37;
      border-color: #f5c2c7;
    }

    #progressWrap { display: none; }

    progress {
      width: 100%;
      height: 16px;
      border-radius: 999px;
      overflow: hidden;
    }

    progress::-webkit-progress-bar {
      background: #edf3f9;
      border-radius: 999px;
    }

    progress::-webkit-progress-value {
      background: linear-gradient(90deg, #0d6efd, #20c997);
      border-radius: 999px;
    }

    #progressMeta {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.5;
    }

    .outputs {
      display: grid;
      gap: 14px;
    }

    h3 {
      margin: 0 0 8px;
      font-size: 1rem;
    }

    textarea {
      width: 100%;
      height: 220px;
      resize: vertical;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      font-size: 0.95rem;
      line-height: 1.45;
      background: #fcfdff;
      color: var(--text);
    }

    textarea:focus,
    input[type="file"]:focus,
    button:focus {
      outline: 2px solid #7fb3ff;
      outline-offset: 1px;
    }

    @media (min-width: 860px) {
      .outputs {
        grid-template-columns: 1fr 1fr;
      }

      textarea {
        height: 320px;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="card">
      <h1>AI Transcription + Translation</h1>
      <p class="subtitle">Upload audio/video and get transcript + English translation with speaker labels.</p>
    </section>

    <section class="card controls">
      <input id="f" type="file" accept="audio/*,video/*" />
      <div class="control-row">
        <button id="go">Transcribe + Translate</button>
        <p id="s" class="status" data-state="idle">Ready</p>
      </div>
      <div id="progressWrap">
        <progress id="p" value="0" max="100"></progress>
        <div id="progressMeta"></div>
      </div>
    </section>

    <section class="card outputs">
      <div>
        <h3>Transcript</h3>
        <textarea id="ar" placeholder="Transcript will appear here..."></textarea>
      </div>
      <div>
        <h3>Translation (English)</h3>
        <textarea id="en" placeholder="English translation will appear here..."></textarea>
      </div>
    </section>
  </main>

  <script>
    const f = document.getElementById('f');
    const s = document.getElementById('s');
    const ar = document.getElementById('ar');
    const en = document.getElementById('en');
    const p = document.getElementById('p');
    const progressWrap = document.getElementById('progressWrap');
    const progressMeta = document.getElementById('progressMeta');
    let lastShownProgress = 0;
    let lastShownBackendPercent = 0;
    const runningOnBackend =
      window.location.protocol.startsWith("http") &&
      (window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost") &&
      window.location.port === "8000";
    const API_BASE = runningOnBackend ? "" : "http://127.0.0.1:8000";

    const setStatus = (text, state) => {
      s.textContent = text;
      s.dataset.state = state;
    };

    const phaseLabel = (phase) => {
      const map = {
        queued: "Queued",
        checking_api_key: "Checking API key",
        initializing_openai: "Initializing OpenAI",
        initializing_local: "Initializing local model",
        transcribing: "Transcribing",
        translating: "Translating",
        labeling_speakers: "Labeling speakers",
        complete: "Complete",
        failed: "Failed"
      };
      return map[phase] || phase || "Processing";
    };

    const fmtSeconds = (seconds) => {
      if (seconds == null) return "—";
      const n = Math.max(0, Math.round(seconds));
      const m = Math.floor(n / 60);
      const s = n % 60;
      return `${m}:${String(s).padStart(2, "0")}`;
    };

    const startJobWithUploadProgress = (formData) => {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", `${API_BASE}/process`);

        xhr.upload.onprogress = (evt) => {
          if (!evt.lengthComputable) return;
          const uploadPercent = (evt.loaded / evt.total) * 100;
          const shownPercent = Math.min(10, uploadPercent * 0.1);
          p.value = shownPercent;
          progressMeta.innerHTML = `
            <div><strong>${uploadPercent.toFixed(1)}%</strong> • Uploading</div>
            <div>Sent: ${(evt.loaded / (1024 * 1024)).toFixed(2)} MB / ${(evt.total / (1024 * 1024)).toFixed(2)} MB</div>
          `;
        };

        xhr.onload = () => {
          let data = {};
          try {
            data = xhr.responseText ? JSON.parse(xhr.responseText) : {};
          } catch {
            data = { error: "Invalid JSON response from backend." };
          }
          resolve({ ok: xhr.status >= 200 && xhr.status < 300, status: xhr.status, data });
        };

        xhr.onerror = () => reject(new Error("Network error during upload."));
        xhr.send(formData);
      });
    };

    document.getElementById('go').onclick = async () => {
      if (!f.files[0]) return alert("Choose a file first.");

      setStatus("Uploading...", "idle");
      ar.value = "";
      en.value = "";
      p.value = 0;
      lastShownProgress = 0;
      lastShownBackendPercent = 0;
      progressMeta.textContent = "";
      progressWrap.style.display = "block";

      const fd = new FormData();
      fd.append("file", f.files[0]);

      let startData;
      let startOk;
      try {
        const startResult = await startJobWithUploadProgress(fd);
        startData = startResult.data;
        startOk = startResult.ok;
      } catch (e) {
        setStatus("Backend not reachable", "error");
        return;
      }

      if (!startOk) {
        setStatus("Error: " + (startData.error || "unknown"), "error");
        return;
      }

      const jobId = startData.job_id;
      setStatus("Processing...", "idle");

      while (true) {
        let progressRes;
        let data;
        try {
          progressRes = await fetch(`${API_BASE}/progress/${jobId}`);
          data = await progressRes.json();
        } catch (e) {
          setStatus("Connection lost", "error");
          break;
        }

        if (!progressRes.ok) {
          setStatus("Error: " + (data.error || "unknown"), "error");
          break;
        }

        const rawBackendPercent = data.progress_percent || 0;
        lastShownBackendPercent = Math.max(lastShownBackendPercent, rawBackendPercent);
        const rawProgress = 10 + (lastShownBackendPercent * 0.9);
        lastShownProgress = Math.max(lastShownProgress, rawProgress);
        p.value = lastShownProgress;
        progressMeta.innerHTML = `
          <div><strong>${lastShownBackendPercent.toFixed(1)}%</strong> • ${phaseLabel(data.phase)}</div>
          <div>Elapsed: ${fmtSeconds(data.elapsed_seconds)} • ETA: ${fmtSeconds(data.eta_seconds)}</div>
        `;

        if (data.status === "done") {
          setStatus("Done", "done");
          ar.value = data.transcript || data.arabic_transcript || "";
          en.value = data.translation || data.english_translation || "";
          break;
        }

        if (data.status === "error") {
          setStatus("Error: " + (data.error || "unknown"), "error");
          break;
        }

        await new Promise((r) => setTimeout(r, 1000));
      }
    };
  </script>
</body>
</html>
